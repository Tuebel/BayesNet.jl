var documenterSearchIndex = {"docs":
[{"location":"graph/#Graph.jl","page":"Graph.jl","title":"Graph.jl","text":"","category":"section"},{"location":"graph/","page":"Graph.jl","title":"Graph.jl","text":"Pages   = [\"graph.md\"]","category":"page"},{"location":"graph/","page":"Graph.jl","title":"Graph.jl","text":"Modules = [BayesNet]\nPages   = [\"src/Graph.jl\", \"Math.jl\"]","category":"page"},{"location":"graph/#BayesNet.AbstractNode","page":"Graph.jl","title":"BayesNet.AbstractNode","text":"AbstractNode{name,child_names}\n\nGeneral graph traversing algorithms are defined on this type. name is typically a symbol and child_names a tuple of symbols.\n\nIf a node is a leaf (has nod children), it does not depend on any other variables and should have a fully specified model.\n\n\n\n\n\n","category":"type"},{"location":"graph/#Base.rand-Union{Tuple{varname}, Tuple{AbstractNode{varname}, NamedTuple, Vararg{Integer}}} where varname","page":"Graph.jl","title":"Base.rand","text":"rand(node, [variables, dims...])\n\nGenerate the random variables from the model by traversing the child nodes. Each node is evaluated only once and the dims are only applied to leafs. The variables parameter allows to condition the model and will not be re-sampled.\n\n\n\n\n\n","category":"method"},{"location":"graph/#BayesNet.childnames-Union{Tuple{AbstractNode{<:Any, names}}, Tuple{names}} where names","page":"Graph.jl","title":"BayesNet.childnames","text":"childnames(node)\n\nExtracts a tuple of the names of the child nodes.\n\n\n\n\n\n","category":"method"},{"location":"graph/#BayesNet.children-Tuple{AbstractNode}","page":"Graph.jl","title":"BayesNet.children","text":"children(node)\n\nReturns a tuple of the child nodes\n\n\n\n\n\n","category":"method"},{"location":"graph/#BayesNet.evaluate-Tuple{AbstractNode, NamedTuple}","page":"Graph.jl","title":"BayesNet.evaluate","text":"evaluate(node, variables)\n\nEvaluate only the deterministic nodes in the graph given the random variables. All required random variables are assumed to be available.\n\n\n\n\n\n","category":"method"},{"location":"graph/#BayesNet.merge_value-Union{Tuple{name}, Tuple{Any, AbstractNode{name}, Any}} where name","page":"Graph.jl","title":"BayesNet.merge_value","text":"merge_value(variables, node, value)\n\nRight to left merges the value for the node with the correct name into the previously sampled variables. Allows to override / modify previous values. If the value is nothing, the variable does not get merged\n\n\n\n\n\n","category":"method"},{"location":"graph/#BayesNet.model-Tuple{AbstractNode}","page":"Graph.jl","title":"BayesNet.model","text":"model(node)\n\nReturns the callable model of the node. Note that a Callable struct are not type stable and should be wrapped by a (anonymous) function.\n\n\n\n\n\n","category":"method"},{"location":"graph/#BayesNet.nodename-Union{Tuple{AbstractNode{name}}, Tuple{name}} where name","page":"Graph.jl","title":"BayesNet.nodename","text":"nodename(node)\n\nExtracts the name of the node\n\n\n\n\n\n","category":"method"},{"location":"graph/#BayesNet.parents-Tuple{AbstractNode, Any}","page":"Graph.jl","title":"BayesNet.parents","text":"parents(root::AbstractNode, node_name)\n\nReturns a SequentializedGraph for the parents of the node_name node up until the root node.\n\n\n\n\n\n","category":"method"},{"location":"graph/#BayesNet.prior-Union{Tuple{AbstractNode{name}}, Tuple{name}} where name","page":"Graph.jl","title":"BayesNet.prior","text":"prior(node)\n\nThe prior of a node are all the child nodes. Returns a SequentializedGraph for the prior \n\n\n\n\n\n","category":"method"},{"location":"graph/#BayesNet.rng-Tuple{AbstractNode}","page":"Graph.jl","title":"BayesNet.rng","text":"model(node)\n\nReturns the random number generator of the node.\n\n\n\n\n\n","category":"method"},{"location":"graph/#BayesNet.traverse-Union{Tuple{varnames}, Tuple{name}, Tuple{Any, AbstractNode{name}, NamedTuple{varnames}, Vararg{Any}}} where {name, varnames}","page":"Graph.jl","title":"BayesNet.traverse","text":"traverse(fn, node, variables, [args...])\n\nEffectively implements a depth first search to all nodes of the graph.\n\nfn(node, variables, args...) is a function of the current node, the variables gathered from the recursions and args of the traverse function. The return values of fn are accumulated in a NamedTuple indexed by the node name. Only the first value of a node is considered, repeated calls for the same node name are ignored. If nothing is returned, the value is ignored. p…\n\n\n\n\n\n","category":"method"},{"location":"graph/#Bijectors.bijector-Tuple{AbstractNode}","page":"Graph.jl","title":"Bijectors.bijector","text":"bijector(node)\n\nInfer the bijectors of the model by traversing the child nodes. Internally a random is used to instantiate the models.\n\n\n\n\n\n","category":"method"},{"location":"graph/#DensityInterface.logdensityof-Tuple{AbstractNode, NamedTuple}","page":"Graph.jl","title":"DensityInterface.logdensityof","text":"logdensityof(node, variables)\n\nCalculate the logdensity of the model given the variables by traversing the child nodes. Each node is evaluated only once.\n\n\n\n\n\n","category":"method"},{"location":"graph/#BayesNet.add_logdensity-Tuple{Any, Any}","page":"Graph.jl","title":"BayesNet.add_logdensity","text":"add_logdensity(A, B)\n\nAdd logdensities from different devices by converting them to CPU Arrays explicitly.\n\n\n\n\n\n","category":"method"},{"location":"nodes/#Predefined-Node-Types","page":"Predefined Node Types","title":"Predefined Node Types","text":"","category":"section"},{"location":"nodes/","page":"Predefined Node Types","title":"Predefined Node Types","text":"Pages   = [\"nodes.md\"]","category":"page"},{"location":"nodes/#SimpleNode.jl","page":"Predefined Node Types","title":"SimpleNode.jl","text":"","category":"section"},{"location":"nodes/","page":"Predefined Node Types","title":"Predefined Node Types","text":"Modules = [BayesNet]\nPages   = [\"SimpleNode.jl\"]","category":"page"},{"location":"nodes/#BayesNet.SimpleNode","page":"Predefined Node Types","title":"BayesNet.SimpleNode","text":"SimpleNode(name, rng, distribution_type, children)\n\nBasic implementation of an AbstractNode with the main purpose of unit testing the graph library. Represents a named variable and depends on child nodes. Does not support logdensityof multiple samples, since no broadcasting or reduction is implemented.\n\n\n\n\n\n","category":"type"},{"location":"nodes/#BroadcastedNode.jl","page":"Predefined Node Types","title":"BroadcastedNode.jl","text":"","category":"section"},{"location":"nodes/","page":"Predefined Node Types","title":"Predefined Node Types","text":"Modules = [BayesNet]\nPages   = [\"BroadcastedNode.jl\"]","category":"page"},{"location":"nodes/#BayesNet.BroadcastedNode","page":"Predefined Node Types","title":"BayesNet.BroadcastedNode","text":"BroadcastedNode\n\nBroadcasts the parameters of the children using a BroadcastedDistribution. Also takes care of matching the dimensions for broadcasting multiple samples. model is a function which generates a BroadcastedDistribution given the nodes child values as parameters. child_sizes are the dims of a single sample from the child node and model_dims the dims of the broadcasted distribution which results from a single sample of all child nodes.\n\n\n\n\n\n","category":"type"},{"location":"nodes/#BayesNet.BroadcastedNode-Tuple{Symbol, Random.AbstractRNG, Any, Vararg{Any}}","page":"Predefined Node Types","title":"BayesNet.BroadcastedNode","text":"BroadcastedNode(name, rng, distribution, params...)\n\nConstruct the node as leaf (no children) by broadcasting the distribution over the params. The resulting BroadcastedDistribution acts like a product distribution, reducing the ndims of the params.\n\n\n\n\n\n","category":"method"},{"location":"nodes/#BayesNet.BroadcastedNode-Tuple{Symbol, Random.AbstractRNG, Union{Function, Type}, Tuple}","page":"Predefined Node Types","title":"BayesNet.BroadcastedNode","text":"BroadcastedNode(name, rng, distribution, children)\n\nConstruct a node which automatically broadcasts the distribution over the parameters given by the children. The resulting BroadcastedDistribution acts like a product distribution, reducing the ndims for the minimal realization of the distribution given the children.\n\n\n\n\n\n","category":"method"},{"location":"nodes/#BayesNet.broadcast_model-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Predefined Node Types","title":"BayesNet.broadcast_model","text":"broadcast_model(fn, dims)\n\nWraps the distribution generating function with a BroadcastedDistribution given the reduction dims.\n\n\n\n\n\n","category":"method"},{"location":"nodes/#BayesNet.insertdims-Union{Tuple{B}, Tuple{O}, Tuple{Any, Tuple{Vararg{Int64, O}}, Tuple{Vararg{Int64, B}}}} where {O, B}","page":"Predefined Node Types","title":"BayesNet.insertdims","text":"insertdims(A, child_size, model_dims)\n\nReshape A by inserting dims of length one to make it compatible for broadcasting multiple random samples of differently shaped children. child_size are the dims of a single sample from the child node and model_dims the dims of the broadcasted distribution which results from a single sample of all child nodes.\n\nRationale\n\nWhen proposing multiple samples, originally matching dims of the BroadcastedDistribution do not work anymore. E.g. if one child has (3,) and the other (3,2) sized samples, proposing multiple samples result in incompatible dimensions (3,5) and (3,2,5). Julia expands dimensions of length one when broadcasting, so reshaping the array with dimensions of length one enables proposing multiple samples, for the above: (3,5) insertdims → (3,1,5) broadcast → (3,2,5) https://freecontent.manning.com/vectorizing-your-code-using-broadcasting/ https://discourse.julialang.org/t/designating-the-axes-for-broadcasting/29203/2\n\n\n\n\n\n","category":"method"},{"location":"nodes/#DeterministicNode.jl","page":"Predefined Node Types","title":"DeterministicNode.jl","text":"","category":"section"},{"location":"nodes/","page":"Predefined Node Types","title":"Predefined Node Types","text":"Modules = [BayesNet]\nPages   = [\"DeterministicNode.jl\"]","category":"page"},{"location":"nodes/#BayesNet.DeterministicNode","page":"Predefined Node Types","title":"BayesNet.DeterministicNode","text":"DeterministicNode\n\nThis node only takes part in the generative rand process but is not random. Instead a deterministic function fn is provided, e.g. rendering an image for a pose. It does not change the joint logdensity of the graph by returning a logdensity of zero.\n\n\n\n\n\n","category":"type"},{"location":"nodes/#ModifierNode.jl","page":"Predefined Node Types","title":"ModifierNode.jl","text":"","category":"section"},{"location":"nodes/","page":"Predefined Node Types","title":"Predefined Node Types","text":"Modules = [BayesNet]\nPages   = [\"ModifierNode.jl\"]","category":"page"},{"location":"nodes/#BayesNet.ModifierNode","page":"Predefined Node Types","title":"BayesNet.ModifierNode","text":"ModifierNode\n\nWraps another node and represents the same variable as the wrapped node. For the model create a new type e.g. ModifierModel and implement:\n\nrand(rng,::AbstractRNG, model::ModifierModel, x), where x is a randomly drawn value from the wrapped node.\nlogdensityof(model::ModifierModel, x, ℓ), where x is the value of the evaluated variable and ℓ the logdensity returned by the wrapped model\n\nWhen traversing the graph, the children of the wrapped node are returned. \n\n\n\n\n\n","category":"type"},{"location":"#BayesNet.jl","page":"BayesNet.jl","title":"BayesNet.jl","text":"","category":"section"},{"location":"","page":"BayesNet.jl","title":"BayesNet.jl","text":"Minimal implementation of a Bayesian Network which is a directed acyclic graph (DAG) where each variable conditionally depends on a set of parent variables (Wikpedia).","category":"page"},{"location":"","page":"BayesNet.jl","title":"BayesNet.jl","text":"By convention, each node in the graph represents a variable and has a unique name associated to it. Exceptions can be made for specific node implementations, i.e. a modifier which post-processes the result of its child node. A node is defined by the following abstract type:","category":"page"},{"location":"","page":"BayesNet.jl","title":"BayesNet.jl","text":"AbstractNode","category":"page"},{"location":"","page":"BayesNet.jl","title":"BayesNet.jl","text":"All implementations expect the following methods are expected to be implemented or the fields of the default implementation to be available:","category":"page"},{"location":"","page":"BayesNet.jl","title":"BayesNet.jl","text":"children(node)::Tuple{Vararg{<:AbstractNode}} = node.children\nmodel(node)::Function = node.model\nrng(node)::AbstractRNG = node.rng","category":"page"},{"location":"","page":"BayesNet.jl","title":"BayesNet.jl","text":"For the specific behavior specify one or many of the following methods for your type:","category":"page"},{"location":"","page":"BayesNet.jl","title":"BayesNet.jl","text":"rand_barrier(node::YourNode, variables::NamedTuple, dims...)\nevaluate_barrier(node::YourNode, variables::NamedTuple)\nlogdensityof_barrier(node::YourNode, variables::NamedTuple)\nbijector_barrier(node::YourNode, variables::NamedTuple)","category":"page"},{"location":"#Naming-Convention","page":"BayesNet.jl","title":"Naming Convention","text":"","category":"section"},{"location":"","page":"BayesNet.jl","title":"BayesNet.jl","text":"Naming of parent-child relationship is reversed in a Bayesian network compared to DAGs. The probability of a child variable y given a parent variable x is p(yx). However, node x is the parent of node y in the resulting graph x  y.","category":"page"},{"location":"","page":"BayesNet.jl","title":"BayesNet.jl","text":"Programming is done more intuitively using the graph & node notation, thus we use parent x  y.","category":"page"},{"location":"","page":"BayesNet.jl","title":"BayesNet.jl","text":"@license BSD-3 https://opensource.org/licenses/BSD-3-Clause\nCopyright (c) 2023, Institute of Automatic Control - RWTH Aachen University\nAll rights reserved. ","category":"page"}]
}
